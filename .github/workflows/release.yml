name: Release

on:
  push:
    branches: [main]
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., 1.0.2). Leave empty to auto-increment patch version.'
        required: false
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# Prevent concurrent releases to avoid conflicts
concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build-and-push-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    outputs:
      trigger_docker_build: ${{ steps.update_versions.outputs.trigger_docker_build }}
      docker_version: ${{ steps.update_versions.outputs.docker_version }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Calculate version
      id: calc_version
      run: |
        # Determine version based on trigger type
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.version }}" ]; then
          # Manual release with specified version
          VERSION="${{ github.event.inputs.version }}"
          echo "Using manually specified version: $VERSION"
        else
          # Auto-release: find next available patch version
          # Fetch all tags first
          git fetch --tags
          
          # Get latest tag or use default
          LATEST_TAG=$(git tag -l "v*" | sort -V | tail -1)
          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="v1.0.0"
            echo "No tags found, starting from v1.0.0"
          fi
          
          LATEST_VERSION=${LATEST_TAG#v}
          IFS='.' read -r major minor patch <<< "$LATEST_VERSION"
          
          # Ensure variables are set
          major=${major:-1}
          minor=${minor:-0}
          patch=${patch:-0}
          
          # Find next available version
          NEW_PATCH=$((patch + 1))
          while git rev-parse "v$major.$minor.$NEW_PATCH" >/dev/null 2>&1; do
            echo "Version v$major.$minor.$NEW_PATCH already exists, trying next..."
            NEW_PATCH=$((NEW_PATCH + 1))
          done
          
          VERSION="$major.$minor.$NEW_PATCH"
          echo "Auto-incrementing from $LATEST_VERSION to $VERSION"
        fi
        
        # Output the version for other steps
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Calculated version: $VERSION"

    - name: Update all version references
      id: update_versions
      run: |
        VERSION="${{ steps.calc_version.outputs.version }}"
        
        # Update Chart.yaml version
        sed -i "s/^version:.*/version: $VERSION/" helm/airia-test-pod/Chart.yaml
        sed -i "s/^appVersion:.*/appVersion: \"$VERSION\"/" helm/airia-test-pod/Chart.yaml
        
        # Update application version references
        sed -i "s/version: str = \"[^\"]*\"/version: str = \"$VERSION\"/" app/config.py
        sed -i "s/app = FastAPI(title=\"Airia Infrastructure Test Pod\", version=\"[^\"]*\")/app = FastAPI(title=\"Airia Infrastructure Test Pod\", version=\"$VERSION\")/" app/main.py
        sed -i "s/\"version\": \"[^\"]*\"/\"version\": \"$VERSION\"/" app/main.py
        
        # Update template fallback versions (only lines with FALLBACK_VERSION comment)
        sed -i "/FALLBACK_VERSION:/s/textContent = 'v[^']*'/textContent = 'v$VERSION'/" templates/dashboard.html
        sed -i "/FALLBACK_VERSION:/s/textContent = 'v[^']*'/textContent = 'v$VERSION'/" templates/index.html
        
        echo "Updated all version references to $VERSION"
        
        # Show what changed
        echo "Changes made:"
        git diff --no-index /dev/null helm/airia-test-pod/Chart.yaml | grep "^+" | grep -E "(version|appVersion)" || true
        git diff --no-index /dev/null app/config.py | grep "^+" | grep version || true
        git diff --no-index /dev/null app/main.py | grep "^+" | grep version || true
        git diff --no-index /dev/null templates/dashboard.html | grep "^+" | grep textContent || true
        git diff --no-index /dev/null templates/index.html | grep "^+" | grep textContent || true
        
        # Commit version updates back to repository and create tag
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add -A
        if git diff --staged --quiet; then
          echo "No version changes to commit"
        else
          git commit -m "Auto-update versions to $VERSION [skip ci]"
          echo "Committed version updates to repository"
        fi

        # Pull latest changes to avoid conflicts, then push version updates to main
        if git pull --rebase origin main; then
          echo "Successfully pulled latest changes"
        else
          echo "Rebase failed, attempting to resolve automatically..."
          # If rebase fails due to conflicts, try to resolve Chart.yaml conflicts automatically
          if git status | grep -q "helm/airia-test-pod/Chart.yaml"; then
            echo "Detected Chart.yaml conflict, resolving automatically..."
            # Use our version (the newer version number should win)
            git checkout --ours helm/airia-test-pod/Chart.yaml
            git add helm/airia-test-pod/Chart.yaml
            if git rebase --continue; then
              echo "Successfully resolved Chart.yaml conflict"
            else
              echo "Error: Could not automatically resolve conflicts"
              git rebase --abort
              exit 1
            fi
          else
            echo "Error: Failed to pull latest changes with unresolvable conflicts"
            git rebase --abort
            exit 1
          fi
        fi
        
        if git push origin main; then
          echo "Successfully pushed version updates to main branch"
        else
          echo "Error: Failed to push version updates to main branch"
          exit 1
        fi
        
        # Then create and push the git tag
        if git rev-parse "v$VERSION" >/dev/null 2>&1; then
          echo "Tag v$VERSION already exists, skipping tag creation"
        else
          git tag -a "v$VERSION" -m "Release v$VERSION"
          if git push origin "v$VERSION"; then
            echo "Successfully created and pushed tag v$VERSION"
            # Set output to indicate we need to build Docker image for this version
            echo "trigger_docker_build=true" >> $GITHUB_OUTPUT
            echo "docker_version=$VERSION" >> $GITHUB_OUTPUT
          else
            echo "Error: Failed to push tag v$VERSION"
            exit 1
          fi
        fi

    - name: Install Helm
      uses: azure/setup-helm@v4
      with:
        version: v3.14.0

    - name: Package Helm chart
      run: |
        helm package helm/airia-test-pod --destination ./helm-packages


    - name: Set version output
      id: version
      run: |
        # Use the version calculated in the previous step
        echo "version=${{ steps.calc_version.outputs.version }}" >> $GITHUB_OUTPUT

    - name: Upload Helm chart to release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ steps.version.outputs.version }}
        name: v${{ steps.version.outputs.version }}
        files: ./helm-packages/*.tgz
        generate_release_notes: true

    - name: Setup Helm repository files
      if: success()
      run: |
        # Create docs directory for Helm repository
        mkdir -p docs
        cp ./helm-packages/*.tgz docs/
        
        # Generate index.yaml for Helm repository
        helm repo index docs --url https://davidpacold.github.io/airia-test-pod/
        
        # Configure git with [skip ci] to prevent infinite loops
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add docs/
        git commit -m "Update Helm repository with v${{ steps.version.outputs.version }} [skip ci]" || exit 0
        git push origin main

  # Build and publish Docker image for the version tag
  build-version-docker:
    needs: build-and-push-release
    runs-on: ubuntu-latest
    if: needs.build-and-push-release.outputs.trigger_docker_build == 'true'
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Checkout repository at version tag
      uses: actions/checkout@v4
      with:
        ref: v${{ needs.build-and-push-release.outputs.docker_version }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata for version tag
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=tag
          type=semver,pattern={{version}},value=v${{ needs.build-and-push-release.outputs.docker_version }}
          type=semver,pattern={{major}}.{{minor}},value=v${{ needs.build-and-push-release.outputs.docker_version }}
          type=semver,pattern={{major}},value=v${{ needs.build-and-push-release.outputs.docker_version }}

    - name: Build and push Docker image for version
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Generate version deployment instructions
      run: |
        echo "## ðŸŽ¯ Version ${{ needs.build-and-push-release.outputs.docker_version }} Released!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Docker image with semantic version tags published:" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo '```bash' >> $GITHUB_STEP_SUMMARY
        echo "# Pull the version-tagged image" >> $GITHUB_STEP_SUMMARY
        echo "docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build-and-push-release.outputs.docker_version }}" >> $GITHUB_STEP_SUMMARY
        echo "docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ needs.build-and-push-release.outputs.docker_version }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "# Use in production:" >> $GITHUB_STEP_SUMMARY
        echo "image:" >> $GITHUB_STEP_SUMMARY
        echo "  repository: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}" >> $GITHUB_STEP_SUMMARY
        echo "  tag: ${{ needs.build-and-push-release.outputs.docker_version }}" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY